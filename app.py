import streamlit as st
from streamlit import session_state
from pymongo import MongoClient
import streamlit as st
import base64
import os
import numpy as np
import dotenv
import pandas as pd
from zipfile import ZipFile
import io
from phe import paillier
import json
import os
import phe


dotenv.load_dotenv()

@st.cache_resource
def init_connection():
    MONGO_URI = os.getenv("MONGO_URI")
    return MongoClient(MONGO_URI)

client = init_connection()
db = client["encrypted_data"]
users_collection = db["user_data"]

session_state = st.session_state
if "user_index" not in st.session_state:
    st.session_state["user_index"] = 0
    
    
def keypair_dump_jwk(pub, priv, date=None):
    """Serializer for public-private keypair, to JWK format."""
    from datetime import datetime
    if date is None:
        date = datetime.now().strftime('%Y-%m-%dT%H:%M:%S')

    rec_pub = {
        'kty': 'DAJ',
        'alg': 'PAI-GN1',
        'key_ops': ['encrypt'],
        'n': phe.util.int_to_base64(pub.n),
        'kid': 'Paillier public key generated by phe on {}'.format(date)
    }

    rec_priv = {
        'kty': 'DAJ',
        'key_ops': ['decrypt'],
        'p': phe.util.int_to_base64(priv.p),
        'q': phe.util.int_to_base64(priv.q),
        'kid': 'Paillier private key generated by phe on {}'.format(date)
    }

    priv_jwk = json.dumps(rec_priv)
    pub_jwk = json.dumps(rec_pub)
    return pub_jwk, priv_jwk

def keypair_load_jwk(pub_jwk, priv_jwk):
    """Deserializer for public-private keypair, from JWK format."""
    rec_pub = json.loads(pub_jwk)
    rec_priv = json.loads(priv_jwk)
    # Do some basic checks                                                                                                                                                      
    assert rec_pub['kty'] == "DAJ", "Invalid public key type"
    assert rec_pub['alg'] == "PAI-GN1", "Invalid public key algorithm"
    assert rec_priv['kty'] == "DAJ", "Invalid private key type"
    pub_n = phe.util.base64_to_int(rec_pub['n'])
    pub = paillier.PaillierPublicKey(pub_n)
    priv_p = phe.util.base64_to_int(rec_priv['p'])
    priv_q = phe.util.base64_to_int(rec_priv['q'])
    priv = paillier.PaillierPrivateKey(pub, priv_p, priv_q)
    return pub, priv

def envec_dump_json(pubkey, enc_vals, indent=None):
    """Serializes a vector of encrypted numbers into a simple JSON format."""
    from phe.util import int_to_base64
    R = {}
    R['public_key'] = {
        'n': int_to_base64(pubkey.n),
    }
    R['values'] = [
        (int_to_base64(x.ciphertext()), x.exponent) for x in enc_vals
    ]
    return json.dumps(R, indent=indent)


def envec_load_json(R_json):
    """Deserializes a vector of encrypted numbers."""
    from phe.util import base64_to_int
    R = json.loads(R_json)
    R_pubkey = R['public_key']
    R_values = R['values']

    # deserialized values:
    pubkey_d = paillier.PaillierPublicKey(n=base64_to_int(R_pubkey['n']))
    values_d = [
        paillier.EncryptedNumber(pubkey_d, ciphertext=base64_to_int(v[0]), exponent=int(v[1]))
        for v in R_values
    ]
    return values_d

def generate_keypair():
    return paillier.generate_paillier_keypair()


def encrypt_message(public_key, message):
    return public_key.encrypt(message)


def decrypt_message(private_key, encrypted_message):
    return private_key.decrypt(encrypted_message)


def add_encrypted_messages(encrypted_message1, encrypted_message2):
    return encrypted_message1 + encrypted_message2

def mean(df, column):
    li = df[column].iloc[0]
    for i in range(1, len(df[column])):
        li = li + df[column].iloc[i]
    return (li/len(df[column]))


def summation(df, column):
    li = df[column].iloc[0]
    for i in range(1, len(df[column])):
        li = li + df[column].iloc[i]
    return li

def weighted_average(df, column):
    li = df[column].iloc[0]
    for i in range(1, len(df[column])):
        li = li + (df[column].iloc[i] * (i+1))
    sum_ = (len(df[column])*(len(df[column])+1))/2
    return (li/sum_)

def signup():
    st.title("Signup Page")
    with st.form("signup_form"):
        st.write("Fill in the details below to create an account:")
        name = st.text_input("Name:")
        email = st.text_input("Email:")
        age = st.number_input("Age:", min_value=0, max_value=120)
        sex = st.radio("Sex:", ("Male", "Female", "Other"))
        password = st.text_input("Password:", type="password")
        confirm_password = st.text_input("Confirm Password:", type="password")

        if st.form_submit_button("Signup"):
            if password == confirm_password:
                user = create_account(name, email, age, sex, password)
                session_state["logged_in"] = True
                session_state["user_info"] = user
            else:
                st.error("Passwords do not match. Please try again.")


def check_login(username, password):
    user = users_collection.find_one({"email": username, "password": password})
    if user:
        session_state["logged_in"] = True
        session_state["user_info"] = user
        st.success("Login successful!")
        return user
    else:
        st.error("Invalid credentials. Please try again.")
        return None

def initialize_database():
    try:
        if "users" not in db.list_collection_names():
            db.create_collection("users")
    except Exception as e:
        print(f"Error initializing database: {e}")


def create_account(name, email, age, sex, password):
    try:
        user_info = {
            "name": name,
            "email": email,
            "age": age,
            "sex": sex,
            "password": password,
            "files": None,
        }
        result = users_collection.insert_one(user_info)
        user_info["_id"] = result.inserted_id
        st.success("Account created successfully! You can now login.")
        return user_info
    except Exception as e:
        st.error(f"Error creating account: {e}")
        return None

def login():
    st.title("Login Page")
    username = st.text_input("Email:")
    password = st.text_input("Password:", type="password")

    login_button = st.button("Login")

    if login_button:
        user = check_login(username, password)
        if user is not None:
            session_state["logged_in"] = True
            session_state["user_info"] = user
        else:
            st.error("Invalid credentials. Please try again.")


def render_dashboard(user_info):
    try:
        st.title(f"Welcome to the Dashboard, {user_info['name']}!")
        st.subheader("User Information:")
        st.write(f"Name: {user_info['name']}")
        st.write(f"Sex: {user_info['sex']}")
        st.write(f"Age: {user_info['age']}")
        st.image("image.jpg", use_column_width=True)

    except Exception as e:
        st.error(f"Error rendering dashboard: {e}")

        

def main():
    st.title("Privacy-Preserving Data Analysis")
    page = st.sidebar.radio(
        "Go to",
        ("Signup/Login", "Dashboard", "File Upload", "Statistical Analysis"),
        key="Pages",
    )

    if page == "Signup/Login":
        st.title("Signup/Login Page")
        login_or_signup = st.radio(
            "Select an option", ("Login", "Signup"), key="login_signup"
        )
        if login_or_signup == "Login":
            login()
        else:
            signup()

    elif page == "Dashboard":
        if session_state.get("logged_in"):
            render_dashboard(session_state["user_info"])
        else:
            st.warning("Please login/signup to view the dashboard.")

    

    elif page == "File Upload":
        if session_state.get("logged_in"):
            st.title("CSV Upload")
            uploaded_file = st.file_uploader(
                "Upload a File", type=["csv"]
            )
            if uploaded_file is not None:
                st.write("Name: %s" % uploaded_file.name)
                st.write("Type: %s" % uploaded_file.type)
                st.write("Size: %s bits" % uploaded_file.size)

                if st.button("Encrypt and Save"):
                    df = pd.read_csv(uploaded_file)
                    public_key, private_key = generate_keypair()
                    for column in df.columns:
                        try:
                            df[column] = df[column].apply(lambda x: encrypt_message(public_key, x))
                            df[column] = df[column].apply(lambda x: envec_dump_json(public_key, [x]))
                            st.write(f"Column {column} encrypted successfully!")
                        except Exception as e:
                            st.error(f"Error encrypting column {column}: {e}")
                    df.to_csv("encrypted_data.csv", index=False)

                    with open("encrypted_data.csv", "rb") as f:
                        data = f.read()
                        user_info = session_state["user_info"]
                        if user_info["files"] is None:
                            user_info["files"] = []
                        file_data = {
                            "name": uploaded_file.name,
                            "data": base64.b64encode(data).decode("utf-8"),
                        }
                        user_info["files"].append(file_data)
                        users_collection.update_one(
                            {"_id": user_info["_id"]},
                            {"$set": {"files": user_info["files"]}},
                        )
                    st.success("File uploaded successfully!")
                    public_key_jwk, private_key_jwk = keypair_dump_jwk(public_key, private_key)
                    with open("phe_key.pub", "w") as F:
                        F.write(public_key_jwk + "\n")
                        print("Written public key to {}".format(F.name))
                        print("n={}".format(public_key.n))

                    with open("phe_key.priv", "w") as F:
                        F.write(private_key_jwk + "\n")
                        print("Written private key to {}".format(F.name))
                        print("p={}, q={}".format(private_key.p, private_key.q))
                    buf = io.BytesIO()
                    with ZipFile(buf, "x") as zip:
                        zip.write("phe_key.pub", "public_key.pub")
                        zip.write("phe_key.priv", "private_key.priv")
                    zip_bytes = buf.getvalue()
                    st.download_button(label="Download Keys", data=zip_bytes,file_name="paillier_keys.zip", mime="application/zip")
        else:
            st.warning("Please login/signup to access this page.")

    elif page == "Statistical Analysis":
        if session_state.get("logged_in"):
            st.title("Statistical Analysis of the Data")
            user_info = session_state["user_info"]
            if user_info["files"]:
                st.write("Select the file to perform statistical analysis:")
                files = [file["name"] for file in user_info["files"]]
                datas = {file["name"]: file["data"] for file in user_info["files"]}
                files.insert(0, "Select a file")
                file = st.selectbox("Select a file", files)
                if file != "Select a file":
                    df = pd.read_csv(io.StringIO(base64.b64decode(datas[file]).decode("utf-8")))
                    for column in df.columns:
                        try:
                            df[column] = df[column].apply(lambda x: envec_load_json(x)[0])
                            st.write(f"Column: {column}")
                            st.write(f"Mean: {mean(df, column).ciphertext()}")
                            st.write(f"Summation: {summation(df, column).ciphertext()}")
                            st.write(f"Weighted Average: {weighted_average(df, column).ciphertext()}")
                            st.write("--------------------------------------------------")
                        except Exception as e:
                            print(f"Error performing statistical analysis: {e}")
                st.subheader("To perform statistical analysis on the crypted data, upload the private key.")
                uploaded_file_priv = st.file_uploader(
                    "Upload the private key"
                )
                
                uploaded_file_pub = st.file_uploader(
                    "Upload the public key"
                )
                if uploaded_file_priv is not None and uploaded_file_pub is not None:
                    # save the keys
                    with open(uploaded_file_pub.name, "wb") as F:
                        F.write(uploaded_file_pub.getvalue())
                    with open(uploaded_file_priv.name, "wb") as F:
                        F.write(uploaded_file_priv.getvalue())
                    with open(uploaded_file_pub.name, "r") as F:
                        public_key_jwk = F.read()
                    with open(uploaded_file_priv.name, "r") as F:
                        private_key_jwk = F.read()
                    public_key, private_key = keypair_load_jwk(public_key_jwk, private_key_jwk)
                    st.success("Private key uploaded successfully!")
                    st.write("Decrypting the data...")
                    df = pd.read_csv(io.StringIO(base64.b64decode(datas[file]).decode("utf-8")))
                    for column in df.columns:
                        try:
                            df[column] = df[column].apply(lambda x: envec_load_json(x)[0])
                            st.write(f"Column: {column}")
                            st.write(f"Mean: {decrypt_message(private_key, mean(df, column))}")
                            st.write(f"Summation: {decrypt_message(private_key, summation(df, column))}")
                            st.write(f"Weighted Average: {decrypt_message(private_key, weighted_average(df, column))}")                         
                            st.write("--------------------------------------------------")
                        except Exception as e:
                            print(f"Error performing statistical analysis: {e}")
            else:
                st.warning("No files uploaded yet.")
        else:
            st.warning("Please login/signup to access this page.")

if __name__ == "__main__":
    initialize_database()
    main()
